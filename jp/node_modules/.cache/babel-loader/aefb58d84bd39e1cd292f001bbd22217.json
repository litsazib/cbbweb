{"ast":null,"code":"Object.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar React = require('react');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nvar throttle = function (callback, limit) {\n  var tick = false;\n  return function () {\n    if (!tick) {\n      callback();\n      tick = true;\n      setTimeout(function () {\n        tick = false;\n      }, limit);\n    }\n  };\n};\n\nvar ScrollSpy = function (_a) {\n  var _b;\n\n  var children = _a.children,\n      // refs\n  navContainerRef = _a.navContainerRef,\n      parentScrollContainerRef = _a.parentScrollContainerRef,\n      // throttle\n  _c = _a.scrollThrottle,\n      // throttle\n  scrollThrottle = _c === void 0 ? 300 : _c,\n      // callback\n  onUpdateCallback = _a.onUpdateCallback,\n      // offsets\n  _d = _a.offsetTop,\n      // offsets\n  offsetTop = _d === void 0 ? 0 : _d,\n      _e = _a.offsetBottom,\n      offsetBottom = _e === void 0 ? 0 : _e,\n      // customize attributes\n  _f = _a.useDataAttribute,\n      // customize attributes\n  useDataAttribute = _f === void 0 ? \"to-scrollspy-id\" : _f,\n      _g = _a.activeClass,\n      activeClass = _g === void 0 ? \"active-scroll-spy\" : _g,\n      _h = _a.useBoxMethod,\n      useBoxMethod = _h === void 0 ? true : _h;\n  var scrollContainerRef = React.useRef(null);\n\n  var _j = React.useState(),\n      navContainerItems = _j[0],\n      setNavContainerItems = _j[1]; // prettier-ignore\n  // keeps track of the Id in navcontainer which is active\n  // so as to not update classLists unless it has been updated\n\n\n  var prevIdTracker = React.useRef(\"\"); // To get the nav container items depending on whether the parent ref for the nav container is passed or not\n\n  React.useEffect(function () {\n    var _a;\n\n    navContainerRef ? setNavContainerItems((_a = navContainerRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll(\"[data-\" + useDataAttribute + \"]\")) : setNavContainerItems(document.querySelectorAll(\"[data-\" + useDataAttribute + \"]\")); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [navContainerRef]); // fire once after nav container items are set\n\n  React.useEffect(function () {\n    checkAndUpdateActiveScrollSpy(); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [navContainerItems]);\n\n  var isVisible = function (el) {\n    var rectInView = el.getBoundingClientRect();\n\n    if (useBoxMethod) {\n      var useHeight = (parentScrollContainerRef === null || parentScrollContainerRef === void 0 ? void 0 : parentScrollContainerRef.current) ? parentScrollContainerRef === null || parentScrollContainerRef === void 0 ? void 0 : parentScrollContainerRef.current.offsetHeight : window.innerHeight;\n      var hitbox_top = useHeight;\n      var element_top = rectInView.top;\n      var element_bottom = rectInView.top + useHeight;\n      return hitbox_top < element_bottom + offsetBottom && hitbox_top > element_top - offsetTop;\n    } else {\n      // this decides how much of the element should be visible\n      var leniency = (parentScrollContainerRef === null || parentScrollContainerRef === void 0 ? void 0 : parentScrollContainerRef.current) ? (parentScrollContainerRef === null || parentScrollContainerRef === void 0 ? void 0 : parentScrollContainerRef.current.offsetHeight) * 0.5 : window.innerHeight * 0.5;\n      var useHeight = (parentScrollContainerRef === null || parentScrollContainerRef === void 0 ? void 0 : parentScrollContainerRef.current) ? parentScrollContainerRef === null || parentScrollContainerRef === void 0 ? void 0 : parentScrollContainerRef.current.offsetHeight : window.innerHeight;\n      return rectInView.top + leniency + offsetTop >= 0 && rectInView.bottom - leniency - offsetBottom <= useHeight;\n    }\n  };\n\n  var checkAndUpdateActiveScrollSpy = function () {\n    var scrollParentContainer = scrollContainerRef.current; // if there are no children, return\n\n    if (!(scrollParentContainer && navContainerItems)) return;\n\n    var _loop_1 = function (i) {\n      // get child element\n      var useChild = scrollParentContainer.children.item(i);\n      var elementIsVisible = isVisible(useChild); // check if the element is in the viewport\n\n      if (elementIsVisible) {\n        // if so, get its ID\n        var changeHighlightedItemId_1 = useChild.id; // if the element was same as the one currently active ignore it\n\n        if (prevIdTracker.current === changeHighlightedItemId_1) return {\n          value: void 0\n        }; // now loop over each element in the nav Container\n\n        navContainerItems.forEach(function (el) {\n          var attrId = el.getAttribute(\"data-\" + useDataAttribute); // if the element contains 'active' the class remove it\n\n          if (el.classList.contains(activeClass)) {\n            el.classList.remove(activeClass);\n          } // check if its ID matches the ID we got from the viewport\n          // also make sure it does not already contain the 'active' class\n\n\n          if (attrId === changeHighlightedItemId_1 && !el.classList.contains(activeClass)) {\n            el.classList.add(activeClass);\n\n            if (onUpdateCallback) {\n              onUpdateCallback(changeHighlightedItemId_1);\n            }\n\n            prevIdTracker.current = changeHighlightedItemId_1;\n            window.history.pushState({}, \"\", \"#\" + changeHighlightedItemId_1);\n          }\n        });\n        return \"break\";\n      }\n    }; // loop over all children in scroll container\n\n\n    for (var i = 0; i < scrollParentContainer.children.length; i++) {\n      var state_1 = _loop_1(i);\n\n      if (typeof state_1 === \"object\") return state_1.value;\n      if (state_1 === \"break\") break;\n    }\n  }; // listen for scroll event\n\n\n  parentScrollContainerRef ? // if ref for scrollable div is provided\n  (_b = parentScrollContainerRef.current) === null || _b === void 0 ? void 0 : _b.addEventListener(\"scroll\", throttle(checkAndUpdateActiveScrollSpy, scrollThrottle)) : // else listen for scroll in window\n  window.addEventListener(\"scroll\", throttle(checkAndUpdateActiveScrollSpy, scrollThrottle));\n  return React__namespace.createElement(\"div\", {\n    ref: scrollContainerRef\n  }, children);\n};\n\nexports[\"default\"] = ScrollSpy;","map":{"version":3,"mappings":"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","names":["throttle","callback","limit","tick","setTimeout","ScrollSpy","_a","children","navContainerRef","parentScrollContainerRef","_c","scrollThrottle","onUpdateCallback","_d","offsetTop","_e","offsetBottom","_f","useDataAttribute","_g","activeClass","_h","useBoxMethod","scrollContainerRef","useRef","useState","navContainerItems","setNavContainerItems","prevIdTracker","useEffect","current","querySelectorAll","document","checkAndUpdateActiveScrollSpy","isVisible","el","rectInView","getBoundingClientRect","useHeight","offsetHeight","window","innerHeight","hitbox_top","element_top","top","element_bottom","leniency","bottom","scrollParentContainer","i","useChild","item","elementIsVisible","changeHighlightedItemId_1","id","forEach","attrId","getAttribute","classList","contains","remove","add","history","pushState","length","_b","addEventListener","React","ref"],"sources":["../src/utils/throttle.ts","../src/ScrollSpy/ScrollSpy.tsx"],"sourcesContent":["export const throttle = (callback: () => void, limit: number) => {\n  var tick = false;\n\n  return () => {\n    if (!tick) {\n      callback();\n      tick = true;\n      setTimeout(function () {\n        tick = false;\n      }, limit);\n    }\n  };\n};\n","import * as React from \"react\";\nimport {\n  MutableRefObject,\n  ReactNode,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport { throttle } from \"../utils/throttle\";\n\ninterface ScrollSpyProps {\n  children: ReactNode;\n\n  // refs\n  navContainerRef?: MutableRefObject<HTMLDivElement | null>;\n  parentScrollContainerRef?: MutableRefObject<HTMLDivElement | null>;\n\n  // throttle\n  scrollThrottle?: number;\n\n  // callback\n  onUpdateCallback?: (id: string) => void;\n\n  // offsets\n  offsetTop?: number;\n  offsetBottom?: number;\n\n  // customize attributes\n  useDataAttribute?: string;\n  activeClass?: string;\n\n  useBoxMethod?: boolean;\n}\n\nconst ScrollSpy = ({\n  children,\n\n  // refs\n  navContainerRef,\n  parentScrollContainerRef,\n\n  // throttle\n  scrollThrottle = 300,\n\n  // callback\n  onUpdateCallback,\n\n  // offsets\n  offsetTop = 0,\n  offsetBottom = 0,\n\n  // customize attributes\n  useDataAttribute = \"to-scrollspy-id\",\n  activeClass = \"active-scroll-spy\",\n\n  useBoxMethod = true,\n}: ScrollSpyProps) => {\n  const scrollContainerRef = useRef<HTMLDivElement | null>(null);\n  const [navContainerItems, setNavContainerItems] = useState<NodeListOf<Element> | undefined>(); // prettier-ignore\n\n  // keeps track of the Id in navcontainer which is active\n  // so as to not update classLists unless it has been updated\n  const prevIdTracker = useRef(\"\");\n\n  // To get the nav container items depending on whether the parent ref for the nav container is passed or not\n  useEffect(() => {\n    navContainerRef\n      ? setNavContainerItems(\n          navContainerRef.current?.querySelectorAll(\n            `[data-${useDataAttribute}]`\n          )\n        )\n      : setNavContainerItems(\n          document.querySelectorAll(`[data-${useDataAttribute}]`)\n        );\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [navContainerRef]);\n\n  // fire once after nav container items are set\n  useEffect(() => {\n    checkAndUpdateActiveScrollSpy();\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [navContainerItems]);\n\n  const isVisible = (el: HTMLElement) => {\n    const rectInView = el.getBoundingClientRect();\n\n    if (useBoxMethod) {\n      const useHeight = parentScrollContainerRef?.current\n        ? parentScrollContainerRef?.current.offsetHeight\n        : window.innerHeight;\n      const hitbox_top = useHeight;\n      const element_top = rectInView.top;\n      const element_bottom = rectInView.top + useHeight;\n\n      return (\n        hitbox_top < element_bottom + offsetBottom &&\n        hitbox_top > element_top - offsetTop\n      );\n    } else {\n      // this decides how much of the element should be visible\n      const leniency = parentScrollContainerRef?.current\n        ? parentScrollContainerRef?.current.offsetHeight * 0.5\n        : window.innerHeight * 0.5;\n\n      const useHeight = parentScrollContainerRef?.current\n        ? parentScrollContainerRef?.current.offsetHeight\n        : window.innerHeight;\n\n      return (\n        rectInView.top + leniency + offsetTop >= 0 &&\n        rectInView.bottom - leniency - offsetBottom <= useHeight\n      );\n    }\n  };\n\n  const checkAndUpdateActiveScrollSpy = () => {\n    const scrollParentContainer = scrollContainerRef.current;\n\n    // if there are no children, return\n    if (!(scrollParentContainer && navContainerItems)) return;\n\n    // loop over all children in scroll container\n    for (let i = 0; i < scrollParentContainer.children.length; i++) {\n      // get child element\n      const useChild = scrollParentContainer.children.item(i) as HTMLDivElement;\n\n      const elementIsVisible = isVisible(useChild);\n\n      // check if the element is in the viewport\n      if (elementIsVisible) {\n        // if so, get its ID\n        const changeHighlightedItemId = useChild.id;\n\n        // if the element was same as the one currently active ignore it\n        if (prevIdTracker.current === changeHighlightedItemId) return;\n\n        // now loop over each element in the nav Container\n        navContainerItems.forEach((el) => {\n          const attrId = el.getAttribute(`data-${useDataAttribute}`);\n\n          // if the element contains 'active' the class remove it\n          if (el.classList.contains(activeClass)) {\n            el.classList.remove(activeClass);\n          }\n\n          // check if its ID matches the ID we got from the viewport\n          // also make sure it does not already contain the 'active' class\n          if (\n            attrId === changeHighlightedItemId &&\n            !el.classList.contains(activeClass)\n          ) {\n            el.classList.add(activeClass);\n\n            if (onUpdateCallback) {\n              onUpdateCallback(changeHighlightedItemId);\n            }\n\n            prevIdTracker.current = changeHighlightedItemId;\n            window.history.pushState({}, \"\", `#${changeHighlightedItemId}`);\n          }\n        });\n        break;\n      }\n    }\n  };\n\n  // listen for scroll event\n  parentScrollContainerRef\n    ? // if ref for scrollable div is provided\n      parentScrollContainerRef.current?.addEventListener(\n        \"scroll\",\n        throttle(checkAndUpdateActiveScrollSpy, scrollThrottle)\n      )\n    : // else listen for scroll in window\n      window.addEventListener(\n        \"scroll\",\n        throttle(checkAndUpdateActiveScrollSpy, scrollThrottle)\n      );\n\n  return <div ref={scrollContainerRef}>{children}</div>;\n};\n\nexport default ScrollSpy;\n"]},"metadata":{},"sourceType":"script"}